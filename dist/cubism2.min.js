!(function (t, e) {
    "object" == typeof exports && "undefined" != typeof module
        ? e(exports, require("@pixi/core"), require("@pixi/display"))
        : "function" == typeof define && define.amd
          ? define(["exports", "@pixi/core", "@pixi/display"], e)
          : e(
                (((t = "undefined" != typeof globalThis ? globalThis : t || self).PIXI =
                    t.PIXI || {}),
                (t.PIXI.live2d = t.PIXI.live2d || {})),
                t.PIXI,
                t.PIXI,
            );
})(this, function (t, e, s) {
    "use strict";
    var i = Object.defineProperty,
        r = Math.pow,
        o = (t, e, s) => (
            ((t, e, s) => {
                e in t
                    ? i(t, e, { enumerable: !0, configurable: !0, writable: !0, value: s })
                    : (t[e] = s);
            })(t, "symbol" != typeof e ? e + "" : e, s),
            s
        ),
        n = (t, e, s) =>
            new Promise((i, r) => {
                var o = (t) => {
                        try {
                            a(s.next(t));
                        } catch (e) {
                            r(e);
                        }
                    },
                    n = (t) => {
                        try {
                            a(s.throw(t));
                        } catch (e) {
                            r(e);
                        }
                    },
                    a = (t) => (t.done ? i(t.value) : Promise.resolve(t.value).then(o, n));
                a((s = s.apply(t, e)).next());
            });
    var a, l;
    ((l = a || (a = {})).supportMoreMaskDivisions = !0), (l.setOpacityFromMotion = !1);
    const d = {
            LOG_LEVEL_VERBOSE: 0,
            LOG_LEVEL_WARNING: 1,
            LOG_LEVEL_ERROR: 2,
            LOG_LEVEL_NONE: 999,
            logLevel: 1,
            sound: !0,
            motionSync: !0,
            motionFadingDuration: 500,
            idleMotionFadingDuration: 2e3,
            expressionFadingDuration: 500,
            preserveExpressionOnMotion: !0,
            cubism4: a,
        },
        h = {
            log(t, ...e) {
                d.logLevel <= d.LOG_LEVEL_VERBOSE && console.log(`[${t}]`, ...e);
            },
            warn(t, ...e) {
                d.logLevel <= d.LOG_LEVEL_WARNING && console.warn(`[${t}]`, ...e);
            },
            error(t, ...e) {
                d.logLevel <= d.LOG_LEVEL_ERROR && console.error(`[${t}]`, ...e);
            },
        };
    function u(t, e, s) {
        return t < e ? e : t > s ? s : t;
    }
    function c(t, e) {
        return Math.random() * (e - t) + t;
    }
    function p(t, e, s, i, r) {
        const o = e[i];
        null !== o && typeof o === t && (s[r] = o);
    }
    function g(t, e, s, i, r) {
        const o = e[i];
        Array.isArray(o) && (s[r] = o.filter((e) => null !== e && typeof e === t));
    }
    function f(t) {
        let e = t.lastIndexOf("/");
        return (
            -1 != e && (t = t.slice(0, e)),
            (e = t.lastIndexOf("/")),
            -1 !== e && (t = t.slice(e + 1)),
            t
        );
    }
    function m(t, e) {
        const s = t.indexOf(e);
        -1 !== s && t.splice(s, 1);
    }
    class y extends e.utils.EventEmitter {
        constructor(t, e) {
            super(),
                o(this, "tag"),
                o(this, "settings"),
                o(this, "expressions", []),
                o(this, "defaultExpression"),
                o(this, "currentExpression"),
                o(this, "reserveExpressionIndex", -1),
                o(this, "destroyed", !1),
                (this.settings = t),
                (this.tag = `ExpressionManager(${t.name})`);
        }
        init() {
            (this.defaultExpression = this.createExpression({}, void 0)),
                (this.currentExpression = this.defaultExpression),
                this.stopAllExpressions();
        }
        loadExpression(t) {
            return n(this, null, function* () {
                if (!this.definitions[t])
                    return void h.warn(this.tag, `Undefined expression at [${t}]`);
                if (null === this.expressions[t])
                    return void h.warn(
                        this.tag,
                        `Cannot set expression at [${t}] because it's already failed in loading.`,
                    );
                if (this.expressions[t]) return this.expressions[t];
                const e = yield this._loadExpression(t);
                return (this.expressions[t] = e), e;
            });
        }
        _loadExpression(t) {
            throw new Error("Not implemented.");
        }
        setRandomExpression() {
            return n(this, null, function* () {
                if (this.definitions.length) {
                    const t = [];
                    for (let e = 0; e < this.definitions.length; e++)
                        null !== this.expressions[e] &&
                            this.expressions[e] !== this.currentExpression &&
                            e !== this.reserveExpressionIndex &&
                            t.push(e);
                    if (t.length) {
                        const e = Math.floor(Math.random() * t.length);
                        return this.setExpression(e);
                    }
                }
                return !1;
            });
        }
        resetExpression() {
            this._setExpression(this.defaultExpression);
        }
        restoreExpression() {
            this._setExpression(this.currentExpression);
        }
        setExpression(t) {
            return n(this, null, function* () {
                if (
                    ("number" != typeof t && (t = this.getExpressionIndex(t)),
                    !(t > -1 && t < this.definitions.length))
                )
                    return !1;
                if (t === this.expressions.indexOf(this.currentExpression)) return !1;
                this.reserveExpressionIndex = t;
                const e = yield this.loadExpression(t);
                return (
                    !(!e || this.reserveExpressionIndex !== t) &&
                    ((this.reserveExpressionIndex = -1),
                    (this.currentExpression = e),
                    this._setExpression(e),
                    !0)
                );
            });
        }
        update(t, e) {
            return !this.isFinished() && this.updateParameters(t, e);
        }
        destroy() {
            (this.destroyed = !0), this.emit("destroy");
            (this.definitions = void 0), (this.expressions = void 0);
        }
    }
    const x = 40 / 7.5,
        v = 1 / 150;
    class M {
        constructor() {
            o(this, "targetX", 0),
                o(this, "targetY", 0),
                o(this, "x", 0),
                o(this, "y", 0),
                o(this, "vx", 0),
                o(this, "vy", 0);
        }
        focus(t, e, s = !1) {
            (this.targetX = u(t, -1, 1)),
                (this.targetY = u(e, -1, 1)),
                s && ((this.x = this.targetX), (this.y = this.targetY));
        }
        update(t) {
            const e = this.targetX - this.x,
                s = this.targetY - this.y;
            if (Math.abs(e) < 0.01 && Math.abs(s) < 0.01) return;
            const i = Math.sqrt(r(e, 2) + r(s, 2)),
                o = x / (1e3 / t);
            let n = o * (e / i) - this.vx,
                a = o * (s / i) - this.vy;
            const l = Math.sqrt(r(n, 2) + r(a, 2)),
                d = o * v * t;
            l > d && ((n *= d / l), (a *= d / l)), (this.vx += n), (this.vy += a);
            const h = Math.sqrt(r(this.vx, 2) + r(this.vy, 2)),
                u = 0.5 * (Math.sqrt(r(d, 2) + 8 * d * i) - d);
            h > u && ((this.vx *= u / h), (this.vy *= u / h)),
                (this.x += this.vx),
                (this.y += this.vy);
        }
    }
    class b {
        constructor(t) {
            o(this, "json"),
                o(this, "name"),
                o(this, "url"),
                o(this, "pose"),
                o(this, "physics"),
                (this.json = t);
            const e = t.url;
            if ("string" != typeof e)
                throw new TypeError(
                    "The `url` field in settings JSON must be defined as a string.",
                );
            (this.url = e), (this.name = f(this.url));
        }
        resolveURL(t) {
            return e.utils.url.resolve(this.url, t);
        }
        replaceFiles(t) {
            (this.moc = t(this.moc, "moc")),
                void 0 !== this.pose && (this.pose = t(this.pose, "pose")),
                void 0 !== this.physics && (this.physics = t(this.physics, "physics"));
            for (let e = 0; e < this.textures.length; e++)
                this.textures[e] = t(this.textures[e], `textures[${e}]`);
        }
        getDefinedFiles() {
            const t = [];
            return this.replaceFiles((e) => (t.push(e), e)), t;
        }
        validateFiles(t) {
            const e = (e, s) => {
                const i = this.resolveURL(e);
                if (!t.includes(i)) {
                    if (s)
                        throw new Error(
                            `File "${e}" is defined in settings, but doesn't exist in given files`,
                        );
                    return !1;
                }
                return !0;
            };
            [this.moc, ...this.textures].forEach((t) => e(t, !0));
            return this.getDefinedFiles().filter((t) => e(t, !1));
        }
    }
    var E = ((t) => (
        (t[(t.NONE = 0)] = "NONE"),
        (t[(t.IDLE = 1)] = "IDLE"),
        (t[(t.NORMAL = 2)] = "NORMAL"),
        (t[(t.FORCE = 3)] = "FORCE"),
        t
    ))(E || {});
    class P {
        constructor() {
            o(this, "tag"),
                o(this, "debug", !1),
                o(this, "currentPriority", 0),
                o(this, "reservePriority", 0),
                o(this, "currentGroup"),
                o(this, "currentIndex"),
                o(this, "reservedGroup"),
                o(this, "reservedIndex"),
                o(this, "reservedIdleGroup"),
                o(this, "reservedIdleIndex");
        }
        reserve(t, e, s) {
            if (s <= 0)
                return h.log(this.tag, "Cannot start a motion with MotionPriority.NONE."), !1;
            if (t === this.currentGroup && e === this.currentIndex)
                return h.log(this.tag, "Motion is already playing.", this.dump(t, e)), !1;
            if (
                (t === this.reservedGroup && e === this.reservedIndex) ||
                (t === this.reservedIdleGroup && e === this.reservedIdleIndex)
            )
                return h.log(this.tag, "Motion is already reserved.", this.dump(t, e)), !1;
            if (1 === s) {
                if (0 !== this.currentPriority)
                    return (
                        h.log(
                            this.tag,
                            "Cannot start idle motion because another motion is playing.",
                            this.dump(t, e),
                        ),
                        !1
                    );
                if (void 0 !== this.reservedIdleGroup)
                    return (
                        h.log(
                            this.tag,
                            "Cannot start idle motion because another idle motion has reserved.",
                            this.dump(t, e),
                        ),
                        !1
                    );
                this.setReservedIdle(t, e);
            } else {
                if (s < 3) {
                    if (s <= this.currentPriority)
                        return (
                            h.log(
                                this.tag,
                                "Cannot start motion because another motion is playing as an equivalent or higher priority.",
                                this.dump(t, e),
                            ),
                            !1
                        );
                    if (s <= this.reservePriority)
                        return (
                            h.log(
                                this.tag,
                                "Cannot start motion because another motion has reserved as an equivalent or higher priority.",
                                this.dump(t, e),
                            ),
                            !1
                        );
                }
                this.setReserved(t, e, s);
            }
            return !0;
        }
        start(t, e, s, i) {
            if (1 === i) {
                if ((this.setReservedIdle(void 0, void 0), 0 !== this.currentPriority))
                    return (
                        h.log(
                            this.tag,
                            "Cannot start idle motion because another motion is playing.",
                            this.dump(e, s),
                        ),
                        !1
                    );
            } else {
                if (e !== this.reservedGroup || s !== this.reservedIndex)
                    return (
                        h.log(
                            this.tag,
                            "Cannot start motion because another motion has taken the place.",
                            this.dump(e, s),
                        ),
                        !1
                    );
                this.setReserved(void 0, void 0, 0);
            }
            return !!t && (this.setCurrent(e, s, i), !0);
        }
        complete() {
            this.setCurrent(void 0, void 0, 0);
        }
        setCurrent(t, e, s) {
            (this.currentPriority = s), (this.currentGroup = t), (this.currentIndex = e);
        }
        setReserved(t, e, s) {
            (this.reservePriority = s), (this.reservedGroup = t), (this.reservedIndex = e);
        }
        setReservedIdle(t, e) {
            (this.reservedIdleGroup = t), (this.reservedIdleIndex = e);
        }
        isActive(t, e) {
            return (
                (t === this.currentGroup && e === this.currentIndex) ||
                (t === this.reservedGroup && e === this.reservedIndex) ||
                (t === this.reservedIdleGroup && e === this.reservedIdleIndex)
            );
        }
        reset() {
            this.setCurrent(void 0, void 0, 0),
                this.setReserved(void 0, void 0, 0),
                this.setReservedIdle(void 0, void 0);
        }
        shouldRequestIdleMotion() {
            return void 0 === this.currentGroup && void 0 === this.reservedIdleGroup;
        }
        shouldOverrideExpression() {
            return !d.preserveExpressionOnMotion && this.currentPriority > 1;
        }
        dump(t, e) {
            if (this.debug) {
                return (
                    `\n<Requested> group = "${t}", index = ${e}\n` +
                    [
                        "currentPriority",
                        "reservePriority",
                        "currentGroup",
                        "currentIndex",
                        "reservedGroup",
                        "reservedIndex",
                        "reservedIdleGroup",
                        "reservedIdleIndex",
                    ]
                        .map((t) => "[" + t + "] " + this[t])
                        .join("\n")
                );
            }
            return "";
        }
    }
    const w = 0.5,
        I = new WeakMap(),
        O = new WeakMap(),
        L = new WeakMap(),
        T = new WeakMap(),
        _ = new WeakMap();
    class F {
        static get volume() {
            return this._volume;
        }
        static set volume(t) {
            (this._volume = (t > 1 ? 1 : t < 0 ? 0 : t) || 0),
                this.audios.forEach((t) => (t.volume = this._volume));
        }
        static add(t, e, s, i) {
            const r = new Audio(t);
            return (
                (r.volume = this._volume),
                (r.preload = "auto"),
                (r.crossOrigin = i),
                I.set(r, {
                    ended: () => {
                        this.dispose(r), null == e || e();
                    },
                    error: (e) => {
                        this.dispose(r),
                            h.warn("SoundManager", `Error occurred on "${t}"`, e.error),
                            null == s || s(e.error);
                    },
                }),
                r.addEventListener("ended", I.get(r).ended),
                r.addEventListener("error", I.get(r).error),
                this.audios.push(r),
                r
            );
        }
        static play(t) {
            return new Promise((e, s) => {
                var i;
                null == (i = t.play()) ||
                    i.catch((e) => {
                        t.dispatchEvent(new ErrorEvent("error", { error: e })), s(e);
                    }),
                    t.readyState === t.HAVE_ENOUGH_DATA
                        ? e()
                        : (O.set(t, e), t.addEventListener("canplaythrough", e));
            });
        }
        static addContext(t) {
            const e = new AudioContext();
            return L.set(t, e), this.contexts.push(e), e;
        }
        static addAnalyzer(t, e) {
            const s = e.createMediaElementSource(t),
                i = e.createAnalyser();
            return (
                (i.fftSize = 256),
                (i.minDecibels = -90),
                (i.maxDecibels = -10),
                (i.smoothingTimeConstant = 0.85),
                s.connect(i),
                i.connect(e.destination),
                _.set(t, s),
                T.set(t, i),
                this.analysers.push(i),
                i
            );
        }
        static analyze(t) {
            if (null != t) {
                const e = new Float32Array(t.fftSize);
                let s = 0;
                t.getFloatTimeDomainData(e);
                for (const t of e) s += t * t;
                return parseFloat(Math.sqrt((s / e.length) * 20).toFixed(1));
            }
            return parseFloat(Math.random().toFixed(1));
        }
        static dispose(t) {
            var e, s;
            t.pause(),
                t.removeEventListener("ended", null == (e = I.get(t)) ? void 0 : e.ended),
                t.removeEventListener("error", null == (s = I.get(t)) ? void 0 : s.error),
                t.removeEventListener("canplaythrough", O.get(t)),
                I.delete(t),
                O.delete(t);
            const i = L.get(t);
            L.delete(t), null == i || i.close();
            const r = T.get(t);
            T.delete(t), null == r || r.disconnect();
            const o = _.get(t);
            _.delete(t),
                null == o || o.disconnect(),
                t.removeAttribute("src"),
                m(this.analysers, r),
                m(this.contexts, i),
                m(this.audios, t);
        }
        static destroy() {
            for (let t = this.contexts.length - 1; t >= 0; t--) this.contexts[t].close();
            for (let t = this.audios.length - 1; t >= 0; t--) this.dispose(this.audios[t]);
        }
    }
    o(F, "audios", []), o(F, "analysers", []), o(F, "contexts", []), o(F, "_volume", w);
    var A = "object" == typeof global && global && global.Object === Object && global,
        R = "object" == typeof self && self && self.Object === Object && self,
        j = A || R || Function("return this")(),
        D = j.Symbol,
        S = Object.prototype,
        k = S.hasOwnProperty,
        C = S.toString,
        U = D ? D.toStringTag : void 0;
    var G = Object.prototype.toString;
    var N = "[object Null]",
        H = "[object Undefined]",
        X = D ? D.toStringTag : void 0;
    function W(t) {
        return null == t
            ? void 0 === t
                ? H
                : N
            : X && X in Object(t)
              ? (function (t) {
                    var e = k.call(t, U),
                        s = t[U];
                    try {
                        t[U] = void 0;
                        var i = !0;
                    } catch (o) {}
                    var r = C.call(t);
                    return i && (e ? (t[U] = s) : delete t[U]), r;
                })(t)
              : (function (t) {
                    return G.call(t);
                })(t);
    }
    function $(t) {
        return null != t && "object" == typeof t;
    }
    var B = Array.isArray;
    function V(t) {
        var e = typeof t;
        return null != t && ("object" == e || "function" == e);
    }
    var q = "[object AsyncFunction]",
        Y = "[object Function]",
        z = "[object GeneratorFunction]",
        J = "[object Proxy]";
    function Z(t) {
        if (!V(t)) return !1;
        var e = W(t);
        return e == Y || e == z || e == q || e == J;
    }
    var Q,
        K = j["__core-js_shared__"],
        tt = (Q = /[^.]+$/.exec((K && K.keys && K.keys.IE_PROTO) || ""))
            ? "Symbol(src)_1." + Q
            : "";
    var et = Function.prototype.toString;
    function st(t) {
        if (null != t) {
            try {
                return et.call(t);
            } catch (e) {}
            try {
                return t + "";
            } catch (e) {}
        }
        return "";
    }
    var it = /^\[object .+?Constructor\]$/,
        rt = Function.prototype,
        ot = Object.prototype,
        nt = rt.toString,
        at = ot.hasOwnProperty,
        lt = RegExp(
            "^" +
                nt
                    .call(at)
                    .replace(/[\\^$.*+?()[\]{}|]/g, "\\$&")
                    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") +
                "$",
        );
    function dt(t) {
        return !(!V(t) || ((e = t), tt && tt in e)) && (Z(t) ? lt : it).test(st(t));
    }
    function ht(t, e) {
        var s = (function (t, e) {
            return null == t ? void 0 : t[e];
        })(t, e);
        return dt(s) ? s : void 0;
    }
    var ut = ht(j, "WeakMap");
    function ct() {}
    var pt = 9007199254740991;
    function gt(t) {
        return "number" == typeof t && t > -1 && t % 1 == 0 && t <= pt;
    }
    var ft = Object.prototype;
    function mt(t) {
        var e = t && t.constructor;
        return t === (("function" == typeof e && e.prototype) || ft);
    }
    function yt(t) {
        return $(t) && "[object Arguments]" == W(t);
    }
    var xt = Object.prototype,
        vt = xt.hasOwnProperty,
        Mt = xt.propertyIsEnumerable,
        bt = yt(
            (function () {
                return arguments;
            })(),
        )
            ? yt
            : function (t) {
                  return $(t) && vt.call(t, "callee") && !Mt.call(t, "callee");
              };
    const Et = bt;
    var Pt = "object" == typeof t && t && !t.nodeType && t,
        wt = Pt && "object" == typeof module && module && !module.nodeType && module,
        It = wt && wt.exports === Pt ? j.Buffer : void 0;
    const Ot =
        (It ? It.isBuffer : void 0) ||
        function () {
            return !1;
        };
    var Lt = {};
    (Lt["[object Float32Array]"] =
        Lt["[object Float64Array]"] =
        Lt["[object Int8Array]"] =
        Lt["[object Int16Array]"] =
        Lt["[object Int32Array]"] =
        Lt["[object Uint8Array]"] =
        Lt["[object Uint8ClampedArray]"] =
        Lt["[object Uint16Array]"] =
        Lt["[object Uint32Array]"] =
            !0),
        (Lt["[object Arguments]"] =
            Lt["[object Array]"] =
            Lt["[object ArrayBuffer]"] =
            Lt["[object Boolean]"] =
            Lt["[object DataView]"] =
            Lt["[object Date]"] =
            Lt["[object Error]"] =
            Lt["[object Function]"] =
            Lt["[object Map]"] =
            Lt["[object Number]"] =
            Lt["[object Object]"] =
            Lt["[object RegExp]"] =
            Lt["[object Set]"] =
            Lt["[object String]"] =
            Lt["[object WeakMap]"] =
                !1);
    var Tt,
        _t = "object" == typeof t && t && !t.nodeType && t,
        Ft = _t && "object" == typeof module && module && !module.nodeType && module,
        At = Ft && Ft.exports === _t && A.process,
        Rt = (function () {
            try {
                var t = Ft && Ft.require && Ft.require("util").types;
                return t || (At && At.binding && At.binding("util"));
            } catch (e) {}
        })(),
        jt = Rt && Rt.isTypedArray;
    const Dt = jt
        ? ((Tt = jt),
          function (t) {
              return Tt(t);
          })
        : function (t) {
              return $(t) && gt(t.length) && !!Lt[W(t)];
          };
    var St = (function (t, e) {
            return function (s) {
                return t(e(s));
            };
        })(Object.keys, Object),
        kt = Object.prototype.hasOwnProperty;
    var Ct = ht(j, "Map"),
        Ut = ht(j, "DataView"),
        Gt = ht(j, "Promise"),
        Nt = ht(j, "Set"),
        Ht = "[object Map]",
        Xt = "[object Promise]",
        Wt = "[object Set]",
        $t = "[object WeakMap]",
        Bt = "[object DataView]",
        Vt = st(Ut),
        qt = st(Ct),
        Yt = st(Gt),
        zt = st(Nt),
        Jt = st(ut),
        Zt = W;
    ((Ut && Zt(new Ut(new ArrayBuffer(1))) != Bt) ||
        (Ct && Zt(new Ct()) != Ht) ||
        (Gt && Zt(Gt.resolve()) != Xt) ||
        (Nt && Zt(new Nt()) != Wt) ||
        (ut && Zt(new ut()) != $t)) &&
        (Zt = function (t) {
            var e = W(t),
                s = "[object Object]" == e ? t.constructor : void 0,
                i = s ? st(s) : "";
            if (i)
                switch (i) {
                    case Vt:
                        return Bt;
                    case qt:
                        return Ht;
                    case Yt:
                        return Xt;
                    case zt:
                        return Wt;
                    case Jt:
                        return $t;
                }
            return e;
        });
    const Qt = Zt;
    var Kt = Object.prototype.hasOwnProperty;
    function te(t) {
        if (null == t) return !0;
        if (
            (function (t) {
                return null != t && gt(t.length) && !Z(t);
            })(t) &&
            (B(t) ||
                "string" == typeof t ||
                "function" == typeof t.splice ||
                Ot(t) ||
                Dt(t) ||
                Et(t))
        )
            return !t.length;
        var e = Qt(t);
        if ("[object Map]" == e || "[object Set]" == e) return !t.size;
        if (mt(t))
            return !(function (t) {
                if (!mt(t)) return St(t);
                var e = [];
                for (var s in Object(t)) kt.call(t, s) && "constructor" != s && e.push(s);
                return e;
            })(t).length;
        for (var s in t) if (Kt.call(t, s)) return !1;
        return !0;
    }
    var ee = ((t) => ((t.ALL = "ALL"), (t.IDLE = "IDLE"), (t.NONE = "NONE"), t))(ee || {});
    class se extends e.utils.EventEmitter {
        constructor(t, e) {
            super(),
                o(this, "tag"),
                o(this, "settings"),
                o(this, "motionGroups", {}),
                o(this, "state", new P()),
                o(this, "currentAudio"),
                o(this, "currentAnalyzer"),
                o(this, "currentContext"),
                o(this, "playing", !1),
                o(this, "destroyed", !1),
                (this.settings = t),
                (this.tag = `MotionManager(${t.name})`),
                (this.state.tag = this.tag);
        }
        init(t) {
            (null == t ? void 0 : t.idleMotionGroup) && (this.groups.idle = t.idleMotionGroup),
                this.setupMotions(t),
                this.stopAllMotions();
        }
        setupMotions(t) {
            for (const s of Object.keys(this.definitions)) this.motionGroups[s] = [];
            let e;
            switch (null == t ? void 0 : t.motionPreload) {
                case "NONE":
                    return;
                case "ALL":
                    e = Object.keys(this.definitions);
                    break;
                default:
                    e = [this.groups.idle];
            }
            for (const s of e)
                if (this.definitions[s])
                    for (let t = 0; t < this.definitions[s].length; t++)
                        this.loadMotion(s, t).then();
        }
        loadMotion(t, e) {
            return n(this, null, function* () {
                var s;
                if (!(null == (s = this.definitions[t]) ? void 0 : s[e]))
                    return void h.warn(this.tag, `Undefined motion at "${t}"[${e}]`);
                if (null === this.motionGroups[t][e])
                    return void h.warn(
                        this.tag,
                        `Cannot start motion at "${t}"[${e}] because it's already failed in loading.`,
                    );
                if (this.motionGroups[t][e]) return this.motionGroups[t][e];
                const i = yield this._loadMotion(t, e);
                return this.destroyed
                    ? void 0
                    : ((this.motionGroups[t][e] = null != i ? i : null), i);
            });
        }
        _loadMotion(t, e) {
            throw new Error("Not implemented.");
        }
        speak(t) {
            return n(
                this,
                arguments,
                function* (
                    t,
                    {
                        volume: e = 0.5,
                        expression: s,
                        resetExpression: i = !0,
                        crossOrigin: r,
                        onFinish: o,
                        onError: n,
                    } = {},
                ) {
                    if (!d.sound) return !1;
                    let a, l, u, c;
                    if (this.currentAudio && !this.currentAudio.ended) return !1;
                    const p = t && t.startsWith("data:");
                    if (t && !p) {
                        const e = document.createElement("a");
                        (e.href = t), (c = t = e.href);
                    } else c = "data:audio/";
                    const g = t;
                    if (g)
                        try {
                            (a = F.add(
                                g,
                                (t = this) => {
                                    console.log("Audio finished playing"),
                                        null == o || o(),
                                        i &&
                                            s &&
                                            t.expressionManager &&
                                            t.expressionManager.resetExpression(),
                                        (t.currentAudio = void 0);
                                },
                                (t, e = this) => {
                                    console.log("Error during audio playback:", t),
                                        null == n || n(t),
                                        i &&
                                            s &&
                                            e.expressionManager &&
                                            e.expressionManager.resetExpression(),
                                        (e.currentAudio = void 0);
                                },
                                r,
                            )),
                                (this.currentAudio = a),
                                (F.volume = e),
                                (u = F.addContext(this.currentAudio)),
                                (this.currentContext = u),
                                (l = F.addAnalyzer(this.currentAudio, this.currentContext)),
                                (this.currentAnalyzer = l);
                        } catch (f) {
                            return h.warn(this.tag, "Failed to create audio", c, f), !1;
                        }
                    if (a) {
                        let t = !0;
                        const e = F.play(a).catch((e) => {
                            h.warn(this.tag, "Failed to play audio", a.src, e), (t = !1);
                        });
                        if (d.motionSync && (yield e, !t)) return !1;
                    }
                    return (
                        this.state.shouldOverrideExpression() &&
                            this.expressionManager &&
                            this.expressionManager.resetExpression(),
                        s && this.expressionManager && this.expressionManager.setExpression(s),
                        (this.playing = !0),
                        !0
                    );
                },
            );
        }
        startMotion(t, e) {
            return n(
                this,
                arguments,
                function* (
                    t,
                    e,
                    s = E.NORMAL,
                    {
                        sound: i,
                        volume: r = 0.5,
                        expression: o,
                        resetExpression: n = !0,
                        crossOrigin: a,
                        onFinish: l,
                        onError: u,
                    } = {},
                ) {
                    var c;
                    if (!this.state.reserve(t, e, s)) return !1;
                    if (this.currentAudio && !this.currentAudio.ended && s != E.FORCE) return !1;
                    const p = null == (c = this.definitions[t]) ? void 0 : c[e];
                    if (!p) return !1;
                    let g, f, m, y;
                    this.currentAudio && F.dispose(this.currentAudio);
                    const x = i && i.startsWith("data:");
                    if (i && !x) {
                        const t = document.createElement("a");
                        (t.href = i), (y = i = t.href);
                    } else (y = this.getSoundFile(p)), y && (y = this.settings.resolveURL(y));
                    const v = y;
                    if (v)
                        try {
                            (g = F.add(
                                v,
                                (t = this) => {
                                    console.log("Audio finished playing"),
                                        null == l || l(),
                                        n &&
                                            o &&
                                            t.expressionManager &&
                                            t.expressionManager.resetExpression(),
                                        (t.currentAudio = void 0);
                                },
                                (t, e = this) => {
                                    console.log("Error during audio playback:", t),
                                        null == u || u(t),
                                        n &&
                                            o &&
                                            e.expressionManager &&
                                            e.expressionManager.resetExpression(),
                                        (e.currentAudio = void 0);
                                },
                                a,
                            )),
                                (this.currentAudio = g),
                                (F.volume = r),
                                (m = F.addContext(this.currentAudio)),
                                (this.currentContext = m),
                                (f = F.addAnalyzer(this.currentAudio, this.currentContext)),
                                (this.currentAnalyzer = f);
                        } catch (b) {
                            h.warn(this.tag, "Failed to create audio", y, b);
                        }
                    const M = yield this.loadMotion(t, e);
                    if (g && !te(g.src)) {
                        const t = F.play(g).catch((t) =>
                            h.warn(this.tag, "Failed to play audio", g.src, t),
                        );
                        d.motionSync && (yield t);
                    }
                    return this.state.start(M, t, e, s)
                        ? (this.state.shouldOverrideExpression() &&
                              this.expressionManager &&
                              this.expressionManager.resetExpression(),
                          h.log(this.tag, "Start motion:", this.getMotionName(p)),
                          this.emit("motionStart", t, e, g),
                          o &&
                              this.expressionManager &&
                              this.state.shouldOverrideExpression() &&
                              this.expressionManager.setExpression(o),
                          (this.playing = !0),
                          this._startMotion(M),
                          !0)
                        : (g && !te(g.src) && (F.dispose(g), (this.currentAudio = void 0)), !1);
                },
            );
        }
        startRandomMotion(t, e) {
            return n(
                this,
                arguments,
                function* (
                    t,
                    e,
                    {
                        sound: s,
                        volume: i = 0.5,
                        expression: r,
                        resetExpression: o = !0,
                        crossOrigin: n,
                        onFinish: a,
                        onError: l,
                    } = {},
                ) {
                    const d = this.definitions[t];
                    if (null == d ? void 0 : d.length) {
                        const h = [];
                        for (let e = 0; e < d.length; e++)
                            null === this.motionGroups[t][e] ||
                                this.state.isActive(t, e) ||
                                h.push(e);
                        if (h.length) {
                            const d = h[Math.floor(Math.random() * h.length)];
                            return this.startMotion(t, d, e, {
                                sound: s,
                                volume: i,
                                expression: r,
                                resetExpression: o,
                                crossOrigin: n,
                                onFinish: a,
                                onError: l,
                            });
                        }
                    }
                    return !1;
                },
            );
        }
        stopSpeaking() {
            this.currentAudio && (F.dispose(this.currentAudio), (this.currentAudio = void 0));
        }
        stopAllMotions() {
            this._stopAllMotions(), this.state.reset(), this.stopSpeaking();
        }
        update(t, e) {
            var s;
            return (
                this.isFinished() &&
                    (this.playing && ((this.playing = !1), this.emit("motionFinish")),
                    this.state.shouldOverrideExpression() &&
                        (null == (s = this.expressionManager) || s.restoreExpression()),
                    this.state.complete(),
                    this.state.shouldRequestIdleMotion() &&
                        this.startRandomMotion(this.groups.idle, E.IDLE)),
                this.updateParameters(t, e)
            );
        }
        mouthSync() {
            return this.currentAnalyzer ? F.analyze(this.currentAnalyzer) : 0;
        }
        destroy() {
            var t;
            (this.destroyed = !0),
                this.emit("destroy"),
                this.stopAllMotions(),
                null == (t = this.expressionManager) || t.destroy();
            (this.definitions = void 0), (this.motionGroups = void 0);
        }
    }
    const ie = { x: 0, y: 0, width: 0, height: 0 };
    class re extends e.utils.EventEmitter {
        constructor() {
            super(...arguments),
                o(this, "focusController", new M()),
                o(this, "pose"),
                o(this, "physics"),
                o(this, "originalWidth", 0),
                o(this, "originalHeight", 0),
                o(this, "width", 0),
                o(this, "height", 0),
                o(this, "localTransform", new e.Matrix()),
                o(this, "drawingMatrix", new e.Matrix()),
                o(this, "hitAreas", {}),
                o(this, "textureFlipY", !1),
                o(this, "viewport", [0, 0, 0, 0]),
                o(this, "destroyed", !1);
        }
        init() {
            this.setupLayout(), this.setupHitAreas();
        }
        setupLayout() {
            const t = this,
                e = this.getSize();
            (t.originalWidth = e[0]), (t.originalHeight = e[1]);
            const s = Object.assign({ width: 2, height: 2 }, this.getLayout());
            this.localTransform.scale(s.width / 2, s.height / 2),
                (t.width = this.originalWidth * this.localTransform.a),
                (t.height = this.originalHeight * this.localTransform.d);
            const i =
                    (void 0 !== s.x && s.x - s.width / 2) ||
                    (void 0 !== s.centerX && s.centerX) ||
                    (void 0 !== s.left && s.left - s.width / 2) ||
                    (void 0 !== s.right && s.right + s.width / 2) ||
                    0,
                r =
                    (void 0 !== s.y && s.y - s.height / 2) ||
                    (void 0 !== s.centerY && s.centerY) ||
                    (void 0 !== s.top && s.top - s.height / 2) ||
                    (void 0 !== s.bottom && s.bottom + s.height / 2) ||
                    0;
            this.localTransform.translate(this.width * i, -this.height * r);
        }
        setupHitAreas() {
            const t = this.getHitAreaDefs().filter((t) => t.index >= 0);
            for (const e of t) this.hitAreas[e.name] = e;
        }
        hitTest(t, e) {
            return Object.keys(this.hitAreas).filter((s) => this.isHit(s, t, e));
        }
        isHit(t, e, s) {
            if (!this.hitAreas[t]) return !1;
            const i = this.hitAreas[t].index,
                r = this.getDrawableBounds(i, ie);
            return r.x <= e && e <= r.x + r.width && r.y <= s && s <= r.y + r.height;
        }
        getDrawableBounds(t, e) {
            const s = this.getDrawableVertices(t);
            let i = s[0],
                r = s[0],
                o = s[1],
                n = s[1];
            for (let a = 0; a < s.length; a += 2) {
                const t = s[a],
                    e = s[a + 1];
                (i = Math.min(t, i)),
                    (r = Math.max(t, r)),
                    (o = Math.min(e, o)),
                    (n = Math.max(e, n));
            }
            return (
                null != e || (e = {}),
                (e.x = i),
                (e.y = o),
                (e.width = r - i),
                (e.height = n - o),
                e
            );
        }
        updateTransform(t) {
            this.drawingMatrix.copyFrom(t).append(this.localTransform);
        }
        update(t, e) {
            this.focusController.update(t);
        }
        destroy() {
            (this.destroyed = !0),
                this.emit("destroy"),
                this.motionManager.destroy(),
                (this.motionManager = void 0);
        }
    }
    class oe extends Error {
        constructor(t, e, s, i = !1) {
            super(t), (this.url = e), (this.status = s), (this.aborted = i);
        }
    }
    const ne = class t {
        static createXHR(e, s, i, r, o) {
            const n = new XMLHttpRequest();
            if ((t.allXhrSet.add(n), e)) {
                let s = t.xhrMap.get(e);
                s ? s.add(n) : ((s = new Set([n])), t.xhrMap.set(e, s)),
                    e.listeners("destroy").includes(t.cancelXHRs) ||
                        e.once("destroy", t.cancelXHRs);
            }
            return (
                n.open("GET", s),
                (n.responseType = i),
                (n.onload = () => {
                    (200 !== n.status && 0 !== n.status) || !n.response
                        ? n.onerror()
                        : r(n.response);
                }),
                (n.onerror = () => {
                    h.warn(
                        "XHRLoader",
                        `Failed to load resource as ${n.responseType} (Status ${n.status}): ${s}`,
                    ),
                        o(new oe("Network error.", s, n.status));
                }),
                (n.onabort = () => o(new oe("Aborted.", s, n.status, !0))),
                (n.onloadend = () => {
                    var s;
                    t.allXhrSet.delete(n), e && (null == (s = t.xhrMap.get(e)) || s.delete(n));
                }),
                n
            );
        }
        static cancelXHRs() {
            var e;
            null == (e = t.xhrMap.get(this)) ||
                e.forEach((e) => {
                    e.abort(), t.allXhrSet.delete(e);
                }),
                t.xhrMap.delete(this);
        }
        static release() {
            t.allXhrSet.forEach((t) => t.abort()), t.allXhrSet.clear(), (t.xhrMap = new WeakMap());
        }
    };
    o(ne, "xhrMap", new WeakMap()),
        o(ne, "allXhrSet", new Set()),
        o(
            ne,
            "loader",
            (t, e) =>
                new Promise((e, s) => {
                    ne.createXHR(
                        t.target,
                        t.settings ? t.settings.resolveURL(t.url) : t.url,
                        t.type,
                        (s) => {
                            (t.result = s), e();
                        },
                        s,
                    ).send();
                }),
        );
    let ae = ne;
    function le(t, e) {
        let s = -1;
        return (function i(r, o) {
            if (o) return Promise.reject(o);
            if (r <= s) return Promise.reject(new Error("next() called multiple times"));
            s = r;
            const n = t[r];
            if (!n) return Promise.resolve();
            try {
                return Promise.resolve(n(e, i.bind(null, r + 1)));
            } catch (a) {
                return Promise.reject(a);
            }
        })(0);
    }
    class de {
        static load(t) {
            return le(this.middlewares, t).then(() => t.result);
        }
    }
    o(de, "middlewares", [ae.loader]);
    const he = "Live2DFactory",
        ue = (t, e) =>
            n(this, null, function* () {
                if ("string" == typeof t.source) {
                    const e = yield de.load({ url: t.source, type: "json", target: t.live2dModel });
                    (e.url = t.source), (t.source = e), t.live2dModel.emit("settingsJSONLoaded", e);
                }
                return e();
            }),
        ce = (t, e) =>
            n(this, null, function* () {
                if (t.source instanceof b) return (t.settings = t.source), e();
                if ("object" == typeof t.source) {
                    const s = Ee.findRuntime(t.source);
                    if (s) {
                        const i = s.createModelSettings(t.source);
                        return (t.settings = i), t.live2dModel.emit("settingsLoaded", i), e();
                    }
                }
                throw new TypeError("Unknown settings format.");
            }),
        pe = (t, e) => {
            if (t.settings) {
                const s = Ee.findRuntime(t.settings);
                if (s) return s.ready().then(e);
            }
            return e();
        },
        ge = (t, e) =>
            n(this, null, function* () {
                yield e();
                const s = t.internalModel;
                if (s) {
                    const e = t.settings,
                        i = Ee.findRuntime(e);
                    if (i) {
                        const r = [];
                        e.pose &&
                            r.push(
                                de
                                    .load({ settings: e, url: e.pose, type: "json", target: s })
                                    .then((e) => {
                                        (s.pose = i.createPose(s.coreModel, e)),
                                            t.live2dModel.emit("poseLoaded", s.pose);
                                    })
                                    .catch((e) => {
                                        t.live2dModel.emit("poseLoadError", e),
                                            h.warn(he, "Failed to load pose.", e);
                                    }),
                            ),
                            e.physics &&
                                r.push(
                                    de
                                        .load({
                                            settings: e,
                                            url: e.physics,
                                            type: "json",
                                            target: s,
                                        })
                                        .then((e) => {
                                            (s.physics = i.createPhysics(s.coreModel, e)),
                                                t.live2dModel.emit("physicsLoaded", s.physics);
                                        })
                                        .catch((e) => {
                                            t.live2dModel.emit("physicsLoadError", e),
                                                h.warn(he, "Failed to load physics.", e);
                                        }),
                                ),
                            r.length && (yield Promise.all(r));
                    }
                }
            }),
        fe = (t, s) =>
            n(this, null, function* () {
                if (!t.settings) throw new TypeError("Missing settings.");
                {
                    const i = t.live2dModel,
                        r = Promise.all(
                            t.settings.textures.map((s) =>
                                (function (t, s = {}) {
                                    const i = { resourceOptions: { crossorigin: s.crossOrigin } };
                                    if (e.Texture.fromURL)
                                        return e.Texture.fromURL(t, i).catch((t) => {
                                            if (t instanceof Error) throw t;
                                            const e = new Error("Texture loading error");
                                            throw ((e.event = t), e);
                                        });
                                    i.resourceOptions.autoLoad = !1;
                                    const r = e.Texture.from(t, i);
                                    if (r.baseTexture.valid) return Promise.resolve(r);
                                    const o = r.baseTexture.resource;
                                    return (
                                        null != o._live2d_load ||
                                            (o._live2d_load = new Promise((t, e) => {
                                                const s = (t) => {
                                                    o.source.removeEventListener("error", s);
                                                    const i = new Error("Texture loading error");
                                                    (i.event = t), e(i);
                                                };
                                                o.source.addEventListener("error", s),
                                                    o
                                                        .load()
                                                        .then(() => t(r))
                                                        .catch(s);
                                            })),
                                        o._live2d_load
                                    );
                                })(t.settings.resolveURL(s), {
                                    crossOrigin: t.options.crossOrigin,
                                }),
                            ),
                        );
                    if ((r.catch(ct), yield s(), !t.internalModel))
                        throw new TypeError("Missing internal model.");
                    (i.internalModel = t.internalModel),
                        i.emit("modelLoaded", t.internalModel),
                        (i.textures = yield r),
                        i.emit("textureLoaded", i.textures);
                }
            }),
        me = (t, e) =>
            n(this, null, function* () {
                const s = t.settings;
                if (s instanceof b) {
                    const i = Ee.findRuntime(s);
                    if (!i) throw new TypeError("Unknown model settings.");
                    const r = yield de.load({
                        settings: s,
                        url: s.moc,
                        type: "arraybuffer",
                        target: t.live2dModel,
                    });
                    if (!i.isValidMoc(r)) throw new Error("Invalid moc data");
                    const o = i.createCoreModel(r);
                    return (t.internalModel = i.createInternalModel(o, s, t.options)), e();
                }
                throw new TypeError("Missing settings.");
            }),
        ye = class t {
            static unzip(s, i) {
                return n(this, null, function* () {
                    const r = yield t.getFilePaths(s),
                        o = [];
                    for (const t of i.getDefinedFiles()) {
                        const s = decodeURI(e.utils.url.resolve(i.url, t));
                        r.includes(s) && o.push(s);
                    }
                    const n = yield t.getFiles(s, o);
                    for (let t = 0; t < n.length; t++) {
                        const e = o[t],
                            s = n[t];
                        Object.defineProperty(s, "webkitRelativePath", { value: e });
                    }
                    return n;
                });
            }
            static createSettings(e) {
                return n(this, null, function* () {
                    const s = (yield t.getFilePaths(e)).find(
                        (t) => t.endsWith("model.json") || t.endsWith("model3.json"),
                    );
                    if (!s) throw new Error("Settings file not found");
                    const i = yield t.readText(e, s);
                    if (!i) throw new Error("Empty settings file: " + s);
                    const r = JSON.parse(i);
                    r.url = s;
                    const o = t.live2dFactory.findRuntime(r);
                    if (!o) throw new Error("Unknown settings JSON");
                    return o.createModelSettings(r);
                });
            }
            static zipReader(t, e) {
                return n(this, null, function* () {
                    throw new Error("Not implemented");
                });
            }
            static getFilePaths(t) {
                return n(this, null, function* () {
                    throw new Error("Not implemented");
                });
            }
            static getFiles(t, e) {
                return n(this, null, function* () {
                    throw new Error("Not implemented");
                });
            }
            static readText(t, e) {
                return n(this, null, function* () {
                    throw new Error("Not implemented");
                });
            }
            static releaseReader(t) {}
        };
    o(ye, "live2dFactory"),
        o(ye, "ZIP_PROTOCOL", "zip://"),
        o(ye, "uid", 0),
        o(ye, "factory", (t, e) =>
            n(ye, null, function* () {
                const s = t.source;
                let i, r, o;
                if (
                    ("string" == typeof s && (s.endsWith(".zip") || s.startsWith(ye.ZIP_PROTOCOL))
                        ? ((i = s.startsWith(ye.ZIP_PROTOCOL)
                              ? s.slice(ye.ZIP_PROTOCOL.length)
                              : s),
                          (r = yield de.load({ url: i, type: "blob", target: t.live2dModel })))
                        : Array.isArray(s) &&
                          1 === s.length &&
                          s[0] instanceof File &&
                          s[0].name.endsWith(".zip") &&
                          ((r = s[0]), (i = URL.createObjectURL(r)), (o = s.settings)),
                    r)
                ) {
                    if (!r.size) throw new Error("Empty zip file");
                    const e = yield ye.zipReader(r, i);
                    o || (o = yield ye.createSettings(e)),
                        (o._objectURL = ye.ZIP_PROTOCOL + ye.uid + "/" + o.url);
                    const s = yield ye.unzip(e, o);
                    (s.settings = o),
                        (t.source = s),
                        i.startsWith("blob:") &&
                            t.live2dModel.once("modelLoaded", (t) => {
                                t.once("destroy", function () {
                                    URL.revokeObjectURL(i);
                                });
                            }),
                        ye.releaseReader(e);
                }
                return e();
            }),
        );
    let xe = ye;
    const ve = class t {
        static resolveURL(e, s) {
            var i;
            const r = null == (i = t.filesMap[e]) ? void 0 : i[s];
            if (void 0 === r) throw new Error("Cannot find this file from uploaded files: " + s);
            return r;
        }
        static upload(s, i) {
            return n(this, null, function* () {
                const r = {};
                for (const t of i.getDefinedFiles()) {
                    const o = decodeURI(e.utils.url.resolve(i.url, t)),
                        n = s.find((t) => t.webkitRelativePath === o);
                    n && (r[t] = URL.createObjectURL(n));
                }
                t.filesMap[i._objectURL] = r;
            });
        }
        static createSettings(e) {
            return n(this, null, function* () {
                const s = e.find(
                    (t) => t.name.endsWith("model.json") || t.name.endsWith("model3.json"),
                );
                if (!s) throw new TypeError("Settings file not found");
                const i = yield t.readText(s),
                    r = JSON.parse(i);
                r.url = s.webkitRelativePath;
                const o = Ee.findRuntime(r);
                if (!o) throw new Error("Unknown settings JSON");
                const n = o.createModelSettings(r);
                return (n._objectURL = URL.createObjectURL(s)), n;
            });
        }
        static readText(t) {
            return n(this, null, function* () {
                return new Promise((e, s) => {
                    const i = new FileReader();
                    (i.onload = () => e(i.result)), (i.onerror = s), i.readAsText(t, "utf8");
                });
            });
        }
    };
    o(ve, "live2dFactory"),
        o(ve, "filesMap", {}),
        o(ve, "factory", (t, e) =>
            n(ve, null, function* () {
                if (Array.isArray(t.source) && t.source[0] instanceof File) {
                    const e = t.source;
                    let s = e.settings;
                    if (s) {
                        if (!s._objectURL)
                            throw new Error('"_objectURL" must be specified in ModelSettings');
                    } else s = yield ve.createSettings(e);
                    s.validateFiles(e.map((t) => encodeURI(t.webkitRelativePath))),
                        yield ve.upload(e, s),
                        (s.resolveURL = function (t) {
                            return ve.resolveURL(this._objectURL, t);
                        }),
                        (t.source = s),
                        t.live2dModel.once("modelLoaded", (t) => {
                            t.once("destroy", function () {
                                const t = this.settings._objectURL;
                                if ((URL.revokeObjectURL(t), ve.filesMap[t]))
                                    for (const e of Object.values(ve.filesMap[t]))
                                        URL.revokeObjectURL(e);
                                delete ve.filesMap[t];
                            });
                        });
                }
                return e();
            }),
        );
    let Me = ve;
    const be = class t {
        static registerRuntime(e) {
            t.runtimes.push(e), t.runtimes.sort((t, e) => e.version - t.version);
        }
        static findRuntime(e) {
            for (const s of t.runtimes) if (s.test(e)) return s;
        }
        static setupLive2DModel(e, s, i) {
            return n(this, null, function* () {
                const r = new Promise((t) => e.once("textureLoaded", t)),
                    o = new Promise((t) => e.once("modelLoaded", t)),
                    n = Promise.all([r, o]).then(() => e.emit("ready"));
                yield le(t.live2DModelMiddlewares, { live2dModel: e, source: s, options: i || {} }),
                    yield n,
                    e.emit("load");
            });
        }
        static loadMotion(e, s, i) {
            var r;
            const o = (t) => e.emit("motionLoadError", s, i, t);
            try {
                const n = null == (r = e.definitions[s]) ? void 0 : r[i];
                if (!n) return Promise.resolve(void 0);
                e.listeners("destroy").includes(t.releaseTasks) ||
                    e.once("destroy", t.releaseTasks);
                let a = t.motionTasksMap.get(e);
                a || ((a = {}), t.motionTasksMap.set(e, a));
                let l = a[s];
                l || ((l = []), (a[s] = l));
                const d = e.getMotionFile(n);
                return (
                    null != l[i] ||
                        (l[i] = de
                            .load({
                                url: d,
                                settings: e.settings,
                                type: e.motionDataType,
                                target: e,
                            })
                            .then((r) => {
                                var o;
                                const a = null == (o = t.motionTasksMap.get(e)) ? void 0 : o[s];
                                a && delete a[i];
                                const l = e.createMotion(r, s, n);
                                return e.emit("motionLoaded", s, i, l), l;
                            })
                            .catch((t) => {
                                h.warn(e.tag, `Failed to load motion: ${d}\n`, t), o(t);
                            })),
                    l[i]
                );
            } catch (n) {
                h.warn(e.tag, `Failed to load motion at "${s}"[${i}]\n`, n), o(n);
            }
            return Promise.resolve(void 0);
        }
        static loadExpression(e, s) {
            const i = (t) => e.emit("expressionLoadError", s, t);
            try {
                const r = e.definitions[s];
                if (!r) return Promise.resolve(void 0);
                e.listeners("destroy").includes(t.releaseTasks) ||
                    e.once("destroy", t.releaseTasks);
                let o = t.expressionTasksMap.get(e);
                o || ((o = []), t.expressionTasksMap.set(e, o));
                const n = e.getExpressionFile(r);
                return (
                    null != o[s] ||
                        (o[s] = de
                            .load({ url: n, settings: e.settings, type: "json", target: e })
                            .then((i) => {
                                const o = t.expressionTasksMap.get(e);
                                o && delete o[s];
                                const n = e.createExpression(i, r);
                                return e.emit("expressionLoaded", s, n), n;
                            })
                            .catch((t) => {
                                h.warn(e.tag, `Failed to load expression: ${n}\n`, t), i(t);
                            })),
                    o[s]
                );
            } catch (r) {
                h.warn(e.tag, `Failed to load expression at [${s}]\n`, r), i(r);
            }
            return Promise.resolve(void 0);
        }
        static releaseTasks() {
            this instanceof se ? t.motionTasksMap.delete(this) : t.expressionTasksMap.delete(this);
        }
    };
    o(be, "runtimes", []),
        o(be, "urlToJSON", ue),
        o(be, "jsonToSettings", ce),
        o(be, "waitUntilReady", pe),
        o(be, "setupOptionals", ge),
        o(be, "setupEssentials", fe),
        o(be, "createInternalModel", me),
        o(be, "live2DModelMiddlewares", [xe.factory, Me.factory, ue, ce, pe, ge, fe, me]),
        o(be, "motionTasksMap", new WeakMap()),
        o(be, "expressionTasksMap", new WeakMap());
    let Ee = be;
    (se.prototype._loadMotion = function (t, e) {
        return Ee.loadMotion(this, t, e);
    }),
        (y.prototype._loadExpression = function (t) {
            return Ee.loadExpression(this, t);
        }),
        (Me.live2dFactory = Ee),
        (xe.live2dFactory = Ee);
    const Pe = class t {
        constructor(
            e,
            {
                autoUpdate: s = !0,
                autoHitTest: i = !0,
                autoFocus: r = !0,
                autoInteract: n,
                ticker: a,
            } = {},
        ) {
            o(this, "model"),
                o(this, "destroyed", !1),
                o(this, "_ticker"),
                o(this, "_autoUpdate", !1),
                o(this, "_autoHitTest", !1),
                o(this, "_autoFocus", !1),
                a ||
                    (t.defaultTicker
                        ? (a = t.defaultTicker)
                        : "undefined" != typeof PIXI && (a = PIXI.Ticker.shared)),
                void 0 !== n &&
                    ((i = n),
                    (r = n),
                    h.warn(
                        e.tag,
                        "options.autoInteract is deprecated since v0.5.0, use autoHitTest and autoFocus instead.",
                    )),
                (this.model = e),
                (this.ticker = a),
                (this.autoUpdate = s),
                (this.autoHitTest = i),
                (this.autoFocus = r),
                (i || r) && (this.model.eventMode = "static");
        }
        get ticker() {
            return this._ticker;
        }
        set ticker(t) {
            var e;
            this._ticker && this._ticker.remove(Ie, this),
                (this._ticker = t),
                this._autoUpdate && (null == (e = this._ticker) || e.add(Ie, this));
        }
        get autoUpdate() {
            return this._autoUpdate;
        }
        set autoUpdate(t) {
            var e;
            this.destroyed ||
                (t
                    ? this._ticker
                        ? (this._ticker.add(Ie, this), (this._autoUpdate = !0))
                        : h.warn(
                              this.model.tag,
                              "No Ticker to be used for automatic updates. Either set option.ticker when creating Live2DModel, or expose PIXI to global scope (window.PIXI = PIXI).",
                          )
                    : (null == (e = this._ticker) || e.remove(Ie, this), (this._autoUpdate = !1)));
        }
        get autoHitTest() {
            return this._autoHitTest;
        }
        set autoHitTest(t) {
            t !== this.autoHitTest &&
                (t ? this.model.on("pointertap", Oe, this) : this.model.off("pointertap", Oe, this),
                (this._autoHitTest = t));
        }
        get autoFocus() {
            return this._autoFocus;
        }
        set autoFocus(t) {
            t !== this.autoFocus &&
                (t
                    ? this.model.on("globalpointermove", Le, this)
                    : this.model.off("globalpointermove", Le, this),
                (this._autoFocus = t));
        }
        get autoInteract() {
            return this._autoHitTest && this._autoFocus;
        }
        set autoInteract(t) {
            (this.autoHitTest = t), (this.autoFocus = t);
        }
        onTickerUpdate() {
            const t = this.ticker.deltaMS;
            this.model.update(t);
        }
        onTap(t) {
            this.model.tap(t.global.x, t.global.y);
        }
        onPointerMove(t) {
            this.model.focus(t.global.x, t.global.y);
        }
        destroy() {
            (this.autoFocus = !1),
                (this.autoHitTest = !1),
                (this.autoUpdate = !1),
                (this.ticker = void 0),
                (this.destroyed = !0);
        }
    };
    o(Pe, "defaultTicker");
    let we = Pe;
    function Ie() {
        this.onTickerUpdate();
    }
    function Oe(t) {
        this.onTap(t);
    }
    function Le(t) {
        this.onPointerMove(t);
    }
    class Te extends e.Transform {}
    const _e = new e.Point(),
        Fe = new e.Matrix();
    class Ae extends s.Container {
        constructor(t) {
            super(),
                o(this, "tag", "Live2DModel(uninitialized)"),
                o(this, "internalModel"),
                o(this, "textures", []),
                o(this, "transform", new Te()),
                o(this, "anchor", new e.ObservablePoint(this.onAnchorChange, this, 0, 0)),
                o(this, "glContextID", -1),
                o(this, "elapsedTime", 0),
                o(this, "deltaTime", 0),
                o(this, "automator"),
                (this.automator = new we(this, t)),
                this.once("modelLoaded", () => this.init(t));
        }
        static from(t, e) {
            const s = new this(e);
            return Ee.setupLive2DModel(s, t, e).then(() => s);
        }
        static fromSync(t, e) {
            const s = new this(e);
            return (
                Ee.setupLive2DModel(s, t, e)
                    .then(null == e ? void 0 : e.onLoad)
                    .catch(null == e ? void 0 : e.onError),
                s
            );
        }
        static registerTicker(t) {
            we.defaultTicker = t.shared;
        }
        init(t) {
            this.tag = `Live2DModel(${this.internalModel.settings.name})`;
        }
        onAnchorChange() {
            this.pivot.set(
                this.anchor.x * this.internalModel.width,
                this.anchor.y * this.internalModel.height,
            );
        }
        motion(
            t,
            e,
            s,
            {
                sound: i,
                volume: r = 0.5,
                expression: o,
                resetExpression: n = !0,
                crossOrigin: a,
                onFinish: l,
                onError: d,
            } = {},
        ) {
            return void 0 === e
                ? this.internalModel.motionManager.startRandomMotion(t, s, {
                      sound: i,
                      volume: r,
                      expression: o,
                      resetExpression: n,
                      crossOrigin: a,
                      onFinish: l,
                      onError: d,
                  })
                : this.internalModel.motionManager.startMotion(t, e, s, {
                      sound: i,
                      volume: r,
                      expression: o,
                      resetExpression: n,
                      crossOrigin: a,
                      onFinish: l,
                      onError: d,
                  });
        }
        stopMotions() {
            return this.internalModel.motionManager.stopAllMotions();
        }
        speak(
            t,
            {
                volume: e = 0.5,
                expression: s,
                resetExpression: i = !0,
                crossOrigin: r,
                onFinish: o,
                onError: n,
            } = {},
        ) {
            return this.internalModel.motionManager.speak(t, {
                volume: e,
                expression: s,
                resetExpression: i,
                crossOrigin: r,
                onFinish: o,
                onError: n,
            });
        }
        stopSpeaking() {
            return this.internalModel.motionManager.stopSpeaking();
        }
        expression(t) {
            return this.internalModel.motionManager.expressionManager
                ? void 0 === t
                    ? this.internalModel.motionManager.expressionManager.setRandomExpression()
                    : this.internalModel.motionManager.expressionManager.setExpression(t)
                : Promise.resolve(!1);
        }
        focus(t, e, s = !1) {
            (_e.x = t), (_e.y = e), this.toModelPosition(_e, _e, !0);
            const i = (_e.x / this.internalModel.originalWidth) * 2 - 1,
                r = (_e.y / this.internalModel.originalHeight) * 2 - 1,
                o = Math.atan2(r, i);
            this.internalModel.focusController.focus(Math.cos(o), -Math.sin(o), s);
        }
        tap(t, e) {
            const s = this.hitTest(t, e);
            s.length && (h.log(this.tag, "Hit", s), this.emit("hit", s));
        }
        hitTest(t, e) {
            return (
                (_e.x = t),
                (_e.y = e),
                this.toModelPosition(_e, _e),
                this.internalModel.hitTest(_e.x, _e.y)
            );
        }
        toModelPosition(t, e = t.clone(), s) {
            return (
                s ||
                    (this._recursivePostUpdateTransform(),
                    this.parent
                        ? this.displayObjectUpdateTransform()
                        : ((this.parent = this._tempDisplayObjectParent),
                          this.displayObjectUpdateTransform(),
                          (this.parent = null))),
                this.transform.worldTransform.applyInverse(t, e),
                this.internalModel.localTransform.applyInverse(e, e),
                e
            );
        }
        containsPoint(t) {
            return this.getBounds(!0).contains(t.x, t.y);
        }
        _calculateBounds() {
            this._bounds.addFrame(
                this.transform,
                0,
                0,
                this.internalModel.width,
                this.internalModel.height,
            );
        }
        update(t) {
            (this.deltaTime += t), (this.elapsedTime += t);
        }
        _render(t) {
            t.batch.reset(), t.geometry.reset(), t.shader.reset(), t.state.reset();
            let e = !1;
            this.glContextID !== t.CONTEXT_UID &&
                ((this.glContextID = t.CONTEXT_UID),
                this.internalModel.updateWebGLContext(t.gl, this.glContextID),
                (e = !0));
            for (let r = 0; r < this.textures.length; r++) {
                const s = this.textures[r];
                s.valid &&
                    ((!e && s.baseTexture._glTextures[this.glContextID]) ||
                        (t.gl.pixelStorei(
                            WebGLRenderingContext.UNPACK_FLIP_Y_WEBGL,
                            this.internalModel.textureFlipY,
                        ),
                        t.texture.bind(s.baseTexture, 0)),
                    this.internalModel.bindTexture(
                        r,
                        s.baseTexture._glTextures[this.glContextID].texture,
                    ),
                    (s.baseTexture.touched = t.textureGC.count));
            }
            const s = t.framebuffer.viewport;
            (this.internalModel.viewport = [s.x, s.y, s.width, s.height]),
                this.deltaTime &&
                    (this.internalModel.update(this.deltaTime, this.elapsedTime),
                    (this.deltaTime = 0));
            const i = Fe.copyFrom(t.globalUniforms.uniforms.projectionMatrix).append(
                this.worldTransform,
            );
            this.internalModel.updateTransform(i),
                this.internalModel.draw(t.gl),
                t.state.reset(),
                t.texture.reset();
        }
        destroy(t) {
            this.emit("destroy"),
                (null == t ? void 0 : t.texture) &&
                    this.textures.forEach((e) => e.destroy(t.baseTexture)),
                this.automator.destroy(),
                this.internalModel.destroy(),
                super.destroy(t);
        }
    }
    if (!window.Live2D)
        throw new Error(
            "Could not find Cubism 2 runtime. This plugin requires live2d.min.js to be loaded.",
        );
    const Re = Live2DMotion.prototype.updateParam;
    Live2DMotion.prototype.updateParam = function (t, e) {
        Re.call(this, t, e),
            e.isFinished() &&
                this.onFinishHandler &&
                (this.onFinishHandler(this), delete this.onFinishHandler);
    };
    class je extends AMotion {
        constructor(t) {
            super(),
                o(this, "params", []),
                this.setFadeIn(t.fade_in > 0 ? t.fade_in : d.expressionFadingDuration),
                this.setFadeOut(t.fade_out > 0 ? t.fade_out : d.expressionFadingDuration),
                Array.isArray(t.params) &&
                    t.params.forEach((t) => {
                        const e = t.calc || "add";
                        if ("add" === e) {
                            const e = t.def || 0;
                            t.val -= e;
                        } else if ("mult" === e) {
                            const e = t.def || 1;
                            t.val /= e;
                        }
                        this.params.push({ calc: e, val: t.val, id: t.id });
                    });
        }
        updateParamExe(t, e, s, i) {
            this.params.forEach((e) => {
                t.setParamFloat(e.id, e.val * s);
            });
        }
    }
    class De extends y {
        constructor(t, e) {
            var s;
            super(t, e),
                o(this, "queueManager", new MotionQueueManager()),
                o(this, "definitions"),
                (this.definitions = null != (s = this.settings.expressions) ? s : []),
                this.init();
        }
        isFinished() {
            return this.queueManager.isFinished();
        }
        getExpressionIndex(t) {
            return this.definitions.findIndex((e) => e.name === t);
        }
        getExpressionFile(t) {
            return t.file;
        }
        createExpression(t, e) {
            return new je(t);
        }
        _setExpression(t) {
            return this.queueManager.startMotion(t);
        }
        stopAllExpressions() {
            this.queueManager.stopAllMotions();
        }
        updateParameters(t, e) {
            return this.queueManager.updateParam(t);
        }
    }
    class Se extends se {
        constructor(t, e) {
            super(t, e),
                o(this, "definitions"),
                o(this, "groups", { idle: "idle" }),
                o(this, "motionDataType", "arraybuffer"),
                o(this, "queueManager", new MotionQueueManager()),
                o(this, "lipSyncIds"),
                o(this, "expressionManager"),
                (this.definitions = this.settings.motions),
                this.init(e),
                (this.lipSyncIds = ["PARAM_MOUTH_OPEN_Y"]);
        }
        init(t) {
            super.init(t),
                this.settings.expressions && (this.expressionManager = new De(this.settings, t));
        }
        isFinished() {
            return this.queueManager.isFinished();
        }
        createMotion(t, e, s) {
            const i = Live2DMotion.loadMotion(t),
                r = e === this.groups.idle ? d.idleMotionFadingDuration : d.motionFadingDuration;
            return (
                i.setFadeIn(s.fade_in > 0 ? s.fade_in : r),
                i.setFadeOut(s.fade_out > 0 ? s.fade_out : r),
                i
            );
        }
        getMotionFile(t) {
            return t.file;
        }
        getMotionName(t) {
            return t.file;
        }
        getSoundFile(t) {
            return t.sound;
        }
        _startMotion(t, e) {
            return (
                (t.onFinishHandler = e),
                this.queueManager.stopAllMotions(),
                this.queueManager.startMotion(t)
            );
        }
        _stopAllMotions() {
            this.queueManager.stopAllMotions();
        }
        updateParameters(t, e) {
            return this.queueManager.updateParam(t);
        }
        destroy() {
            super.destroy(), (this.queueManager = void 0);
        }
    }
    class ke {
        constructor(t) {
            o(this, "leftParam"),
                o(this, "rightParam"),
                o(this, "blinkInterval", 4e3),
                o(this, "closingDuration", 100),
                o(this, "closedDuration", 50),
                o(this, "openingDuration", 150),
                o(this, "eyeState", 0),
                o(this, "eyeParamValue", 1),
                o(this, "closedTimer", 0),
                o(this, "nextBlinkTimeLeft", this.blinkInterval),
                (this.coreModel = t),
                (this.leftParam = t.getParamIndex("PARAM_EYE_L_OPEN")),
                (this.rightParam = t.getParamIndex("PARAM_EYE_R_OPEN"));
        }
        setEyeParams(t) {
            (this.eyeParamValue = u(t, 0, 1)),
                this.coreModel.setParamFloat(this.leftParam, this.eyeParamValue),
                this.coreModel.setParamFloat(this.rightParam, this.eyeParamValue);
        }
        update(t) {
            switch (this.eyeState) {
                case 0:
                    (this.nextBlinkTimeLeft -= t),
                        this.nextBlinkTimeLeft < 0 &&
                            ((this.eyeState = 1),
                            (this.nextBlinkTimeLeft =
                                this.blinkInterval +
                                this.closingDuration +
                                this.closedDuration +
                                this.openingDuration +
                                c(0, 2e3)));
                    break;
                case 1:
                    this.setEyeParams(this.eyeParamValue + t / this.closingDuration),
                        this.eyeParamValue <= 0 && ((this.eyeState = 2), (this.closedTimer = 0));
                    break;
                case 2:
                    (this.closedTimer += t),
                        this.closedTimer >= this.closedDuration && (this.eyeState = 3);
                    break;
                case 3:
                    this.setEyeParams(this.eyeParamValue + t / this.openingDuration),
                        this.eyeParamValue >= 1 && (this.eyeState = 0);
            }
        }
    }
    const Ce = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    class Ue extends re {
        constructor(t, e, s) {
            super(),
                o(this, "settings"),
                o(this, "coreModel"),
                o(this, "motionManager"),
                o(this, "eyeBlink"),
                o(this, "eyeballXParamIndex"),
                o(this, "eyeballYParamIndex"),
                o(this, "angleXParamIndex"),
                o(this, "angleYParamIndex"),
                o(this, "angleZParamIndex"),
                o(this, "bodyAngleXParamIndex"),
                o(this, "breathParamIndex"),
                o(this, "textureFlipY", !0),
                o(this, "lipSync", !0),
                o(this, "drawDataCount", 0),
                o(this, "disableCulling", !1),
                o(this, "hasDrawn", !1),
                (this.coreModel = t),
                (this.settings = e),
                (this.motionManager = new Se(e, s)),
                (this.eyeBlink = new ke(t)),
                (this.eyeballXParamIndex = t.getParamIndex("PARAM_EYE_BALL_X")),
                (this.eyeballYParamIndex = t.getParamIndex("PARAM_EYE_BALL_Y")),
                (this.angleXParamIndex = t.getParamIndex("PARAM_ANGLE_X")),
                (this.angleYParamIndex = t.getParamIndex("PARAM_ANGLE_Y")),
                (this.angleZParamIndex = t.getParamIndex("PARAM_ANGLE_Z")),
                (this.bodyAngleXParamIndex = t.getParamIndex("PARAM_BODY_ANGLE_X")),
                (this.breathParamIndex = t.getParamIndex("PARAM_BREATH")),
                this.init();
        }
        init() {
            super.init(),
                this.settings.initParams &&
                    this.settings.initParams.forEach(({ id: t, value: e }) =>
                        this.coreModel.setParamFloat(t, e),
                    ),
                this.settings.initOpacities &&
                    this.settings.initOpacities.forEach(({ id: t, value: e }) =>
                        this.coreModel.setPartsOpacity(t, e),
                    ),
                this.coreModel.saveParam();
            const t = this.coreModel.getModelContext()._$aS;
            (null == t ? void 0 : t.length) && (this.drawDataCount = t.length);
            let e = this.coreModel.drawParamWebGL.culling;
            Object.defineProperty(this.coreModel.drawParamWebGL, "culling", {
                set: (t) => (e = t),
                get: () => !this.disableCulling && e,
            });
            const s = this.coreModel.getModelContext().clipManager,
                i = s.setupClip;
            s.setupClip = (t, e) => {
                i.call(s, t, e), e.gl.viewport(...this.viewport);
            };
        }
        getSize() {
            return [this.coreModel.getCanvasWidth(), this.coreModel.getCanvasHeight()];
        }
        getLayout() {
            const t = {};
            if (this.settings.layout)
                for (const [e, s] of Object.entries(this.settings.layout)) {
                    let i = e;
                    "center_x" === e ? (i = "centerX") : "center_y" === e && (i = "centerY"),
                        (t[i] = s);
                }
            return t;
        }
        updateWebGLContext(t, e) {
            const s = this.coreModel.drawParamWebGL;
            (s.firstDraw = !0), s.setGL(t), (s.glno = e);
            for (const [o, n] of Object.entries(s)) n instanceof WebGLBuffer && (s[o] = null);
            const i = this.coreModel.getModelContext().clipManager;
            i.curFrameNo = e;
            const r = t.getParameter(t.FRAMEBUFFER_BINDING);
            i.getMaskRenderTexture(), t.bindFramebuffer(t.FRAMEBUFFER, r);
        }
        bindTexture(t, e) {
            this.coreModel.setTexture(t, e);
        }
        getHitAreaDefs() {
            var t;
            return (
                (null == (t = this.settings.hitAreas)
                    ? void 0
                    : t.map((t) => ({
                          id: t.id,
                          name: t.name,
                          index: this.coreModel.getDrawDataIndex(t.id),
                      }))) || []
            );
        }
        getDrawableIDs() {
            const t = this.coreModel.getModelContext(),
                e = [];
            for (let s = 0; s < this.drawDataCount; s++) {
                const i = t.getDrawData(s);
                i && e.push(i.getDrawDataID().id);
            }
            return e;
        }
        getDrawableIndex(t) {
            return this.coreModel.getDrawDataIndex(t);
        }
        getDrawableVertices(t) {
            if ("string" == typeof t && -1 === (t = this.coreModel.getDrawDataIndex(t)))
                throw new TypeError("Unable to find drawable ID: " + t);
            return this.coreModel.getTransformedPoints(t).slice();
        }
        hitTest(t, e) {
            return (
                this.hasDrawn ||
                    h.warn(
                        "Trying to hit-test a Cubism 2 model that has not been rendered yet. The result will always be empty since the draw data is not ready.",
                    ),
                super.hitTest(t, e)
            );
        }
        update(t, e) {
            var s, i, r, o;
            super.update(t, e);
            const n = this.coreModel;
            this.emit("beforeMotionUpdate");
            const a = this.motionManager.update(this.coreModel, e);
            if (
                (this.emit("afterMotionUpdate"),
                n.saveParam(),
                null == (s = this.motionManager.expressionManager) || s.update(n, e),
                a || null == (i = this.eyeBlink) || i.update(t),
                this.updateFocus(),
                this.updateNaturalMovements(t, e),
                this.lipSync && this.motionManager.currentAudio)
            ) {
                let t = this.motionManager.mouthSync(),
                    e = 0;
                const s = 1,
                    i = 1.2,
                    r = 0.7;
                t > 0 && (e = 0.4), (t = Math.pow(t, r)), (t = u(t * i, e, s));
                for (let o = 0; o < this.motionManager.lipSyncIds.length; ++o)
                    this.coreModel.setParamFloat(
                        this.coreModel.getParamIndex(this.motionManager.lipSyncIds[o]),
                        t,
                    );
            }
            null == (r = this.physics) || r.update(e),
                null == (o = this.pose) || o.update(t),
                this.emit("beforeModelUpdate"),
                n.update(),
                n.loadParam();
        }
        updateFocus() {
            this.coreModel.addToParamFloat(this.eyeballXParamIndex, this.focusController.x),
                this.coreModel.addToParamFloat(this.eyeballYParamIndex, this.focusController.y),
                this.coreModel.addToParamFloat(this.angleXParamIndex, 30 * this.focusController.x),
                this.coreModel.addToParamFloat(this.angleYParamIndex, 30 * this.focusController.y),
                this.coreModel.addToParamFloat(
                    this.angleZParamIndex,
                    this.focusController.x * this.focusController.y * -30,
                ),
                this.coreModel.addToParamFloat(
                    this.bodyAngleXParamIndex,
                    10 * this.focusController.x,
                );
        }
        updateNaturalMovements(t, e) {
            const s = (e / 1e3) * 2 * Math.PI;
            this.coreModel.addToParamFloat(this.angleXParamIndex, 15 * Math.sin(s / 6.5345) * 0.5),
                this.coreModel.addToParamFloat(
                    this.angleYParamIndex,
                    8 * Math.sin(s / 3.5345) * 0.5,
                ),
                this.coreModel.addToParamFloat(
                    this.angleZParamIndex,
                    10 * Math.sin(s / 5.5345) * 0.5,
                ),
                this.coreModel.addToParamFloat(
                    this.bodyAngleXParamIndex,
                    4 * Math.sin(s / 15.5345) * 0.5,
                ),
                this.coreModel.setParamFloat(
                    this.breathParamIndex,
                    0.5 + 0.5 * Math.sin(s / 3.2345),
                );
        }
        draw(t) {
            const e = this.disableCulling;
            t.getParameter(t.FRAMEBUFFER_BINDING) && (this.disableCulling = !0);
            const s = this.drawingMatrix;
            (Ce[0] = s.a),
                (Ce[1] = s.b),
                (Ce[4] = s.c),
                (Ce[5] = s.d),
                (Ce[12] = s.tx),
                (Ce[13] = s.ty),
                this.coreModel.setMatrix(Ce),
                this.coreModel.draw(),
                (this.hasDrawn = !0),
                (this.disableCulling = e);
        }
        destroy() {
            super.destroy(), (this.coreModel = void 0);
        }
    }
    class Ge extends b {
        constructor(t) {
            if (
                (super(t),
                o(this, "moc"),
                o(this, "textures"),
                o(this, "layout"),
                o(this, "hitAreas"),
                o(this, "initParams"),
                o(this, "initOpacities"),
                o(this, "expressions"),
                o(this, "motions", {}),
                !Ge.isValidJSON(t))
            )
                throw new TypeError("Invalid JSON.");
            (this.moc = t.model), g("string", t, this, "textures", "textures"), this.copy(t);
        }
        static isValidJSON(t) {
            var e;
            return (
                !!t &&
                "string" == typeof t.model &&
                (null == (e = t.textures) ? void 0 : e.length) > 0 &&
                t.textures.every((t) => "string" == typeof t)
            );
        }
        copy(t) {
            p("string", t, this, "name", "name"),
                p("string", t, this, "pose", "pose"),
                p("string", t, this, "physics", "physics"),
                p("object", t, this, "layout", "layout"),
                p("object", t, this, "motions", "motions"),
                g("object", t, this, "hit_areas", "hitAreas"),
                g("object", t, this, "expressions", "expressions"),
                g("object", t, this, "init_params", "initParams"),
                g("object", t, this, "init_opacities", "initOpacities");
        }
        replaceFiles(t) {
            super.replaceFiles(t);
            for (const [e, s] of Object.entries(this.motions))
                for (let i = 0; i < s.length; i++)
                    (s[i].file = t(s[i].file, `motions.${e}[${i}].file`)),
                        void 0 !== s[i].sound &&
                            (s[i].sound = t(s[i].sound, `motions.${e}[${i}].sound`));
            if (this.expressions)
                for (let e = 0; e < this.expressions.length; e++)
                    this.expressions[e].file = t(
                        this.expressions[e].file,
                        `expressions[${e}].file`,
                    );
        }
    }
    const Ne = {
            x: PhysicsHair.Src.SRC_TO_X,
            y: PhysicsHair.Src.SRC_TO_Y,
            angle: PhysicsHair.Src.SRC_TO_G_ANGLE,
        },
        He = {
            x: PhysicsHair.Src.SRC_TO_X,
            y: PhysicsHair.Src.SRC_TO_Y,
            angle: PhysicsHair.Src.SRC_TO_G_ANGLE,
        };
    class Xe {
        constructor(t, e) {
            o(this, "physicsHairs", []),
                (this.coreModel = t),
                e.physics_hair &&
                    (this.physicsHairs = e.physics_hair.map((t) => {
                        const e = new PhysicsHair();
                        return (
                            e.setup(t.setup.length, t.setup.regist, t.setup.mass),
                            t.src.forEach(({ id: t, ptype: s, scale: i, weight: r }) => {
                                const o = Ne[s];
                                o && e.addSrcParam(o, t, i, r);
                            }),
                            t.targets.forEach(({ id: t, ptype: s, scale: i, weight: r }) => {
                                const o = He[s];
                                o && e.addTargetParam(o, t, i, r);
                            }),
                            e
                        );
                    }));
        }
        update(t) {
            this.physicsHairs.forEach((e) => e.update(this.coreModel, t));
        }
    }
    class We {
        constructor(t) {
            o(this, "paramIndex", -1),
                o(this, "partsIndex", -1),
                o(this, "link", []),
                (this.id = t);
        }
        initIndex(t) {
            (this.paramIndex = t.getParamIndex("VISIBLE:" + this.id)),
                (this.partsIndex = t.getPartsDataIndex(PartsDataID.getID(this.id))),
                t.setParamFloat(this.paramIndex, 1);
        }
    }
    class $e {
        constructor(t, e) {
            o(this, "opacityAnimDuration", 500),
                o(this, "partsGroups", []),
                (this.coreModel = t),
                e.parts_visible &&
                    ((this.partsGroups = e.parts_visible.map(({ group: t }) =>
                        t.map(({ id: t, link: e }) => {
                            const s = new We(t);
                            return e && (s.link = e.map((t) => new We(t))), s;
                        }),
                    )),
                    this.init());
        }
        init() {
            this.partsGroups.forEach((t) => {
                t.forEach((t) => {
                    if ((t.initIndex(this.coreModel), t.paramIndex >= 0)) {
                        const e = 0 !== this.coreModel.getParamFloat(t.paramIndex);
                        this.coreModel.setPartsOpacity(t.partsIndex, e ? 1 : 0),
                            this.coreModel.setParamFloat(t.paramIndex, e ? 1 : 0),
                            t.link.length > 0 && t.link.forEach((t) => t.initIndex(this.coreModel));
                    }
                });
            });
        }
        normalizePartsOpacityGroup(t, e) {
            const s = this.coreModel,
                i = 0.5;
            let r = 1,
                o = t.findIndex(
                    ({ paramIndex: t, partsIndex: e }) => e >= 0 && 0 !== s.getParamFloat(t),
                );
            if (o >= 0) {
                const i = s.getPartsOpacity(t[o].partsIndex);
                r = u(i + e / this.opacityAnimDuration, 0, 1);
            } else (o = 0), (r = 1);
            t.forEach(({ partsIndex: t }, e) => {
                if (t >= 0)
                    if (o == e) s.setPartsOpacity(t, r);
                    else {
                        let e,
                            o = s.getPartsOpacity(t);
                        e = r < i ? (-0.5 * r) / i + 1 : ((1 - r) * i) / 0.5;
                        (1 - e) * (1 - r) > 0.15 && (e = 1 - 0.15 / (1 - r)),
                            o > e && (o = e),
                            s.setPartsOpacity(t, o);
                    }
            });
        }
        copyOpacity(t) {
            const e = this.coreModel;
            t.forEach(({ partsIndex: t, link: s }) => {
                if (t >= 0 && s) {
                    const i = e.getPartsOpacity(t);
                    s.forEach(({ partsIndex: t }) => {
                        t >= 0 && e.setPartsOpacity(t, i);
                    });
                }
            });
        }
        update(t) {
            this.partsGroups.forEach((e) => {
                this.normalizePartsOpacityGroup(e, t), this.copyOpacity(e);
            });
        }
    }
    Ee.registerRuntime({
        version: 2,
        test: (t) => t instanceof Ge || Ge.isValidJSON(t),
        ready: () => Promise.resolve(),
        isValidMoc(t) {
            if (t.byteLength < 3) return !1;
            const e = new Int8Array(t, 0, 3);
            return "moc" === String.fromCharCode(...e);
        },
        createModelSettings: (t) => new Ge(t),
        createCoreModel(t) {
            const e = Live2DModelWebGL.loadModel(t),
                s = Live2D.getError();
            if (s) throw s;
            return e;
        },
        createInternalModel: (t, e, s) => new Ue(t, e, s),
        createPose: (t, e) => new $e(t, e),
        createPhysics: (t, e) => new Xe(t, e),
    }),
        (t.Cubism2ExpressionManager = De),
        (t.Cubism2InternalModel = Ue),
        (t.Cubism2ModelSettings = Ge),
        (t.Cubism2MotionManager = Se),
        (t.ExpressionManager = y),
        (t.FileLoader = Me),
        (t.FocusController = M),
        (t.InternalModel = re),
        (t.LOGICAL_HEIGHT = 2),
        (t.LOGICAL_WIDTH = 2),
        (t.Live2DExpression = je),
        (t.Live2DEyeBlink = ke),
        (t.Live2DFactory = Ee),
        (t.Live2DLoader = de),
        (t.Live2DModel = Ae),
        (t.Live2DPhysics = Xe),
        (t.Live2DPose = $e),
        (t.Live2DTransform = Te),
        (t.ModelSettings = b),
        (t.MotionManager = se),
        (t.MotionPreloadStrategy = ee),
        (t.MotionPriority = E),
        (t.MotionState = P),
        (t.SoundManager = F),
        (t.VERSION = "v0.5.0-ls-7"),
        (t.VOLUME = w),
        (t.XHRLoader = ae),
        (t.ZipLoader = xe),
        (t.applyMixins = function (t, e) {
            e.forEach((e) => {
                Object.getOwnPropertyNames(e.prototype).forEach((s) => {
                    "constructor" !== s &&
                        Object.defineProperty(
                            t.prototype,
                            s,
                            Object.getOwnPropertyDescriptor(e.prototype, s),
                        );
                });
            });
        }),
        (t.clamp = u),
        (t.config = d),
        (t.copyArray = g),
        (t.copyProperty = p),
        (t.folderName = f),
        (t.logger = h),
        (t.rand = c),
        (t.remove = m),
        Object.defineProperty(t, Symbol.toStringTag, { value: "Module" });
});
